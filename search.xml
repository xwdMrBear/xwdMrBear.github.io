<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[在springMVC开发中的注解开发]]></title>
      <url>http://weidablog.top/2017/01/14/spring/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p>最近在搭框架的时候,业务层的接口会架一个@transactionalde的注解,这是一个保证事物原子性的注解,同时也声明了这个是搭载在spring框架中的文件.<br>所谓原子性是事物的特质之一,一旦事物具有原子性,他就是一个不可分割的整体,当出现异常时回滚,要么同时成功,要么同时失败,颇有点拖人下水的感觉.</p>
<h2 id="事务管理方式"><a href="#事务管理方式" class="headerlink" title="事务管理方式"></a>事务管理方式</h2><h3 id="TransactionTemplate注解"><a href="#TransactionTemplate注解" class="headerlink" title="TransactionTemplate注解"></a>TransactionTemplate注解</h3><p>spring支持编程式事务管理和声明式事务管理两种方式。</p>
<p>编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p>
<p>声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</p>
<p>显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</p>
<p>声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。</p>
<h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果<br>执行失败则隐式的回滚事务。</p>
<p>对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，spring会将底层连接的自动提交特性设置为false。</p>
<p><b>其中TransactionDefinition接口定义以下特性：</b></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="TransactionDefinition注解"><a href="#TransactionDefinition注解" class="headerlink" title="TransactionDefinition注解"></a>TransactionDefinition注解</h3><p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>*TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h2><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<p>默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</p>
<h2 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h2><p>只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。<br>默认为读写事务。</p>
<h2 id="spring事务回滚规则"><a href="#spring事务回滚规则" class="headerlink" title="spring事务回滚规则"></a>spring事务回滚规则</h2><p>指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。</p>
<p>默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。<br>可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。</p>
<p>还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚</p>
<h2 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h2><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td style="text-align:center">String</td>
<td style="text-align:right">可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td style="text-align:center">enum: Propagation</td>
<td style="text-align:right">可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td style="text-align:center">enum: Isolation</td>
<td style="text-align:right">可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td style="text-align:center">int (in seconds granularity)</td>
<td style="text-align:right">事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td style="text-align:center">Class对象数组，必须继承自Throwable</td>
<td style="text-align:right">导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td style="text-align:center">类名数组，必须继承自Throwable</td>
<td style="text-align:right">导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td style="text-align:center">Class对象数组，必须继承自Throwable</td>
<td style="text-align:right">不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td style="text-align:center">类名数组，必须继承自Throwable</td>
<td style="text-align:right">不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody>
</table>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<p>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>
<blockquote>
<p>摘自博客园</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[毕业设计]]></title>
      <url>http://weidablog.top/2017/01/10/design/</url>
      <content type="html"><![CDATA[<p>前几天忽然有人拉我进一个群,我开始以为又是什么团购秒杀群,刚准备拒绝,然后看了一眼标题,叫2017毕业设计,于是就顺手同意了.之后这件事我也没放在心上,加上我很少上qq,所以当我知道要交一个什么开题报告的时候已经是截至的最后几天了.</p>
<p>我粗略翻了一下之前的聊天记录,我和预想的一样,大部分都索然无味,永远绕不开什么学生管理,档案管理这几个梗.我觉得是因为这几个板块前车太多了,照葫芦画瓢也不算困难.而且毕业既然都说了是设计了.这样的东西,我实在想不出设计的要点在哪里.在我的印象中,毕业设计,尤其是计算机行业,是最容易创新的.例如写个解释器,或者写个象棋AlphaGo之类.但是很多学生的点子完全就是在模仿造轮子,当然我知道造轮子也是需要技术的,而且我目前的状态也在模仿的造轮子,所以我想说的,就是我目前正想摆脱的现状,和我希望千千万万和我一样的同龄人不要陷入的怪圈.</p>
<p>就好像我今天看到的一副漫画一样<br><img src="/img/Design/a.jpg" alt="a"></p>
<p>我觉得,这个世界上技术牛逼的人太多了,但是最火,最值钱的,往往都是些点子好,而不是技术牛.</p>
<p>更加让我感到失望的是我的毕业设计指导老师,我和他素未谋面,但是从名字我可以推断她是一位女性.他在我们的讨论组里反反复复强调毕业设计不要求多大的难度,要有代码量和实现的功能.这句话结合当时的上下文语境,在我理解看来,他的意思就是:<br>你们别去整那些乱七八糟的幺蛾子了,老老实实的实现好增删改查,注册登录,把轮子粘好能跑就行了.</p>
<p>我之前说过这个学校不注重开发学生的潜力,甚至连毕业设计连一点基本的创新都不倡导.让学生做着一些打字员的工作.实现一些现在早就淘汰了的东西.</p>
<p>以下是我设想的毕业设计<br><img src="/img/Design/b.jpg" alt="b"></p>
<p>这是我花几分钟写的一个大纲.之前准备想开发网页,但是我觉得如果那样的话有点鸡肋,因为可以上网的话为什么不直接百度呢?</p>
<p>1月9号微信小程序上线,于是我有了将这个移植成微信小程序的想法.</p>
<p>我知道这个也没有多少创新,但是音乐作为我擅长并喜爱的领域,我觉得我是在我的兴趣和技术上设计.<br>倘若每个人的毕业设计能在一个自己感兴趣的方向上开展,我觉得那也至少会让我觉得好玩的多.<br>我会设计一个特色功能作为主打,以及若干细节,我想我会在以后的学习开发中慢慢补充.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新年展望]]></title>
      <url>http://weidablog.top/2017/01/03/newyear/</url>
      <content type="html"><![CDATA[<p>很抱歉一月三号才开始新年展望,好像这原本是应该年前完成或者说是应该元旦当天正儿八经的”展望”一番<br>但是我就是想今天来总结一下</p>
<p>2016年,我猜想若干年后我去回忆他,对于我来说应该也是很不同寻常的一年,我花了一年的时间去探索,去总结,去寻找,总算在这一年,为我将来五至十年的未来规划了一条看上去还算靠谱的路.其实所谓的靠谱也就是符合现代社会价值观的一些年轻人应该有的打算,如果要用一句话去总结我的2016.我觉得”用灵魂换以生存”这句话是比较靠谱的,因为我觉得那个幻想着自由和乌托邦的我已经不存在了,取而代之的,是一个还算被社会认可的我</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h1><h2 id="一月到三月"><a href="#一月到三月" class="headerlink" title="一月到三月"></a>一月到三月</h2><p>年初我意外的收获到了我原本以为要在很远之后才能得到的东西,因为我身无分文,而且也没有金城武,吴彦祖般的脸庞,我觉得要靠我的内涵和才华去打动一个女孩子,是很花时间,而且很困难的.可偏偏就在这个时候,该来的还是来了.我和我亲爱的女朋友共同生活了半年异地加半年相处的时间,他是一个可爱乖巧的女孩子,这一点深的我心,我不喜欢太过强势的女性,我的择偶标准就是可以在我劳累的时候帮我分担我的烦恼,懂得照顾我的生活.因为我不是一个好逸恶劳的人,我不需要女强人给我事业上的帮助,因为我自己会去争取.相反,像我女朋友这种女性,正是我需要的.如果没有那么任性,我觉得就完美了</p>
<h2 id="三月到六月"><a href="#三月到六月" class="headerlink" title="三月到六月"></a>三月到六月</h2><p>春节刚过我就回到了我早已厌倦的大学,在这里我并非特指我的母校,我只是针对这个扼杀了无数理想青年的坟墓,又被一代代人心向往之,趋之若鹜的大学.<br>我的家庭很传统,传统到我家长辈给我灌输的价值观不敢越社会价值观雷池半步,可惜我没有那么听话,我至今觉得我中学时代的大量阅读给了我很好的启蒙.我一直都想去追求我的理想,而不是被现实扭曲了的那一部分,我当时向往考上大学,因为我觉得大学不用像高中这样上课占据了全部,我可以有更多的时间去寻找我自己的方向,可是后来上了大学发现也就这么回事,老师上课照本宣科,自己教了一个东西,却从来不说我们为什么要去学,在我眼中看来,大学所教的东西的目的有且就只有一个,那就是为了考试.考试通过,皆大欢喜,考试不过,呜呼哀哉,却从来没有人告诉你为什么要学这个,学这个有什么用,他对你的职业规划有哪些帮助,这个学科诞生之初发生了哪些故事,你掌握这门学科,前提需要什么样的知识,以后深入学习又要学习哪些知识…..<br>等等等等,从来没有人和我们说过,在我看来,大学学的那些东西,只有考试一个目的.但是现在看来,不合理的地方简直数不胜数.<br>举几个例子.首先我们只学了一门sqlserver数据库,但是众所周知,企业中就算用收费的数据库基本上都是oracle,如果嫌贵,还有免费的mysql,我看了那么多用人企业的招聘信息,还没见那个地方要求掌握sqlserver.记得我们有一门叫做软件工程的课,刚上的时候听说考试很难,每个同学正襟危坐,仿佛考不过对自己的打击简直如同五雷轰顶,但是我却在想我们为什么要学那门课.现在看来,我觉得软件工程这门课完全可以改名叫如何成为一名项目经理.但是项目经理一般要有3~5年的开发经验,很多东西都是熟能生巧.但是对我们一群连IDE都用不会的学生,上来就讲什么瀑布模型,项目周期,成本预估,风险评估,对于我们这群代码都没有写过几百行,debug都不会用的人.没有任何意义.上课就是老师在上面照着课本念一遍,学生在下面听的稀里糊涂,还要装作一副聚精会神样.还有就是现在每一个学校上来就教c语言,接着c++,好像学c语言才是编程中的贵族,才是大学精神,java只是个民工语言.然后再去弄明白那些晦涩难懂的汇编语言,机器语言才能显得自己多牛逼.我并不能说这些偏底层的东西不好.但是这些东西比较适合那些”精英”们去做理论研究,但是对于这样一个普通的二本学校,我觉得,学校和学生是一样的,要有自知之明,自己摆好定位很重要,不需要清华大学学什么我们学什么,清华的定位就是学生要成为某个领域的尖端,将一些事物的本质拆散了敲碎了去研究透彻,但是,我觉得我们学校的首要任务应该就是就业率和给社会创造生产价值,行有余力,再做研究.但是我觉得大部分学生行有余力都去LOL了吧</p>
<p>在这个学校我看不到对学生潜力的开发,看不到对学生的规划,甚至看不到对学生的尊重.学生找老师,很容易吃闭门羹,甚至会让人感到那是一种君对臣的关系.当然我很幸运,我的班主任,辅导员老师,以及在上半年对我影响很大的桑老师和沈教授,他们对我的帮助是让我受用终身的.在此表示感谢.<br>我只是特指某些在学校居庙堂之高的老师</p>
<p>上学期在班主任的帮助下在沈老师的实验室里面看了三个月的c++编程原理,不得不承认,这是一本很高深的书,里面一些算法和题目,我就得研究个一下午一晚上,其他的时间我都过的很颓废,直到五月份我做出了一个重要的决定.</p>
<h2 id="六月到现在"><a href="#六月到现在" class="headerlink" title="六月到现在"></a>六月到现在</h2><p>我决定认真去走计算机这行.</p>
<p>也算是我的职业规划吧,计算机是我的”老本行”但是本科从来没有认真学过,不过现在我确定了要走这一条路.</p>
<p>我曾经有过很多梦想,当一个流浪歌手,可惜没有这个勇气,去做一个音乐制作人,但是没有这个环境,想去创业当老板,可惜我又没有这个本钱.<br>这就是中国这个社会,你从来不是想做什么就可以去做什么,而是别人觉得你需要做什么,你才能做什么.我也承认自己的决心不够坚定,魄力不够大,但是这个现实,就不存在真正的理想主义,家庭不存在,社会不存在.大学,更不存在.</p>
<p>总而言之 ,除去我在大学认识的很多不错的朋友,老师和同学,除此之外,这个大学让我失望透顶.</p>
<p>我提交了离校申请去外面学习计算机,为自己跨入这行做准备.我资质很普通,我也从来不觉得我是个天才,我只是比普通人更加反感形式,向往自由,并且,多了一点思考而已.</p>
<p>我剩下的半年可以用一天来概括,就是天天拼命的学习和敲代码,这半年技术上的收获很大.也接触到了很多从学校那些老古董那里永远不可能学到的东西.</p>
<h1 id="关于2017"><a href="#关于2017" class="headerlink" title="关于2017"></a>关于2017</h1><p>2017年我觉得对于我是很关键的一年,因为这是我职业生涯的第一年.</p>
<p>首先我准备找一个至少工资能让我满意的工作,我现在不敢奢谈追求,这个社会除了关心你能生产多少价值之外,其余的都不在乎,中国最不缺的就是人,不管是体力劳动还是空洞的脑力劳动,中国都不缺.在中国,努力是廉价的.</p>
<p>首先我希望我的工资可以帮助我还清我欠我母亲的钱,其次可以保证我正常的生活,也就是我和我女朋友租房子的钱,吃饭交通社交娱乐的钱.再加上一点点额外的追求的钱就好.</p>
<p>六月份我将毕业,在确定学历这个敲门砖到底有多重要之前,我仍然不打算回去学校.</p>
<p>未来一年也许还有很多变数,但是我暂时不想考虑,我准备先留在武汉,一来离家近,二来消费不高,三来陪女朋友.<br>之后我会去深圳,因为武汉给我的感觉是臃肿的,他虽然有几乎完善的基础设施,地铁及城际轨道,发达的高铁线路,无数的创业基地,遍地的大学,但是这些依旧不能掩饰这座城市的臃肿不堪,过多的人口,陈旧的行业,以及糟糕的环境,这样的地方是留不住人的.这里人的口号虽然很先进,但是思想依旧传统.造成这些的原因有很多,地理原因,人口结构,历史遗留问题等等.我觉得是近几年无法改善的.<br>相反我觉得深圳这个地方充满了活力, 对于我这样的年轻人是有无穷吸引力的.因为我没有去过.这些也只是我的主观感受<br>现在我最实际的一个计划就是我现在也在寻找一位python的高手,因为我最近正在学,十分想找个人虚心求教,如果你有很好的学习资料和方法,可以通过我的博客联系到我.</p>
<p>以上</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Merry Christmas]]></title>
      <url>http://weidablog.top/2016/12/26/MerryChristmas/</url>
      <content type="html"><![CDATA[<p>又是一个没有雪的冬天<a id="more"></a></p>
<center><br><br>在华中地区武汉<br>是一个从来不会下雪的城市<br>但这应该是全中国冬天最冷的地方<br><br>往年的每个圣诞,我现在都已经记不起来了<br>倒不是我记性不好<br>我想大概是没有什么特别之处<br>可以给予我值得的留恋<br><br>生活过的像水一样<br>记忆自然也是波澜不惊<br><br>唯一值得记住的,大概是某年冬天<br>室友进了一堆苹果<br>打算在平安夜大干一场<br>结果当然是剩了一堆<br>最后兄弟们你两个我三个给帮忙解决了<br>虽然没赚到什么钱,但是<br>这大概是关于这个节日对于我<br>印象最深刻的一次<br><br>大学同窗的笑容,自离开后<br>也很少去回味了<br><br>至于后来,以前,<br>发现真的半点记忆也没有<br>我想<br>关于这个节日的热闹,是他们的,与我无关<br>我本来就不爱凑热闹<br>何况外国人的热闹<br><br>但是,2016年<br>这个圣诞节<br>我想,我应该很难忘记<br><br><img src="/img/20161225/1.jpg" alt="1"><br><br><img src="/img/20161225/2.jpg" alt="2"><br><br><img src="/img/20161225/3.jpg" alt="3"><br><br><img src="/img/20161225/4.jpg" alt="4"><br><br><img src="/img/20161225/5.jpg" alt="5"><br><br><img src="/img/20161225/6.jpg" alt="6"><br><br><img src="/img/20161225/7.jpg" alt="7"><br><br><img src="/img/20161225/8.jpg" alt="8"><br><br><img src="/img/20161225/9.jpg" alt="9"><br><br><br>一年前玩摄影的lofter.<br><a href="http://m188648373571.lofter.com/" target="_blank" rel="external">lofter</a><br><br><br></center>


]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python笔记(二)]]></title>
      <url>http://weidablog.top/2016/12/24/python02/</url>
      <content type="html"><![CDATA[<p>接着上次<a id="more"></a></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a><center>输入</center></h2><center><br>现在，你已经可以用print()输出你想要的结果了。<br>但是，如果要让用户从电脑输入一些字符怎么办？<br>Python提供了一个input()，可以让用户输入字符串，<br>并存放到一个变量里。比如输入用户的<br>&gt;&gt;&gt;name = input()<br>/<em>输入你要输入的数据,例如</em>/<br>张全蛋<br>但是程序运行的时候，没有任何提示信息告诉用户：<br>“嘿，赶紧输入你的名字”，这样显得很不友好。<br>幸好，input()可以让你显示一个字符串来提示用户，于是我们把代码改成：<br><code>name = input(&#39;please enter your name: &#39;)</code><br><code>print(&#39;hello,&#39;, nam</code><br></center>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a><center>输出</center></h2><center><br>再次运行这个程序，你会发现，程序一运行，<br>会首先打印出please enter your name:，<br>这样，用户就可以根据提示，输入名字后，得到hello, xxx的输出：<br><code>C:\Workspace&gt; python hello.py</code><br><code>please enter your name: Michael</code><br><code>hello, Michael</code><br><br></center>

<center><br><code># print absolute value of an integer:</code><br><code>a = 100</code><br><code>if a &gt;= 0:</code><br> <code>print(a)</code><br><code>else:</code><br> <code>print(-a)</code><br>以#开头的语句是注释，注释是给人看的，<br>可以是任意内容，解释器会忽略掉注释。<br>其他每一行都是一个语句，当语句以冒号:结尾时，<br>缩进的语句视为代码块。<br>缩进有利有弊。好处是强迫你写出格式化的代码，<br>但没有规定缩进是几个空格还是Tab。<br>按照约定俗成的管理，应该始终坚持使用4个空格的缩进。<br>缩进的另一个好处是强迫你写出缩进较少的代码，<br>你会倾向于把一段很长的代码拆分成若干函数，<br>从而得到缩进较少的代码。<br>缩进的坏处就是“复制－粘贴”功能失效了，<br>这是最坑爹的地方。当你重构代码时，<br>粘贴过去的代码必须重新检查缩进是否正确。<br>此外，IDE很难像格式化Java代码那样格式化Python代码。<br>最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。<br><br><br>好吧,懒癌犯了,很多东西很杂乱,明天再更!!<br><br><br><br></center>

<h2 id="睡觉"><a href="#睡觉" class="headerlink" title="睡觉!!"></a><center>睡觉!!</center></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python笔记(一)]]></title>
      <url>http://weidablog.top/2016/12/22/python01/</url>
      <content type="html"><![CDATA[<p>嗯,如题<a id="more"></a></p>
<center><br>    在网上看了一个关于爬虫的帖子,感觉很有趣<br>    于是原本打算用lucene+solr做一个<br>    但是感觉的略复杂,加上网上关于爬虫百分之七十<br>    (这个数据室推测的,没有依据)<br>    是用python来做<br>    于是自己也打算学习一下,<br>    打算从现在开始写一个长期贴<br>    来记录本人学习python的总结,和走的一些弯路<br>    权当个人笔记,<br><br></center>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><center>安装</center></h2><center><br>那就从安装开始讲,正儿八经的初学者.<br><br>讲道理我的电脑是windows,于是在网上下载了一个python3.5.1<br>貌似python2和python3的差别很大,<br>而且当初再出新版本的时候,<br>考虑到了效率,python并没有向下兼容<br>所以安装之前一定要考虑清楚<br>在这里,我的建议是装python3版本以上的<br>具体为什么,<br>别问我,我也不知道<br><br>然后安装时可以勾选自动配环境变量,之后默认就可以了<br><br>按道理此时应该是装好了<br>但是我在实际操作过程中,一直在缺失一个kb2999226的服务<br>导致我安装失败了好几次,然后停掉了windows update也没用<br><br>我一气之下把python安装到了linux中<br><br>linux系统其实是自带python的<br>但是因为版本太低,所以建议装一个python3<br><br>在这里,我默认你会使用linux<br>所以解压好之后<br>依次在跟文件夹输入<br><code>./configure</code><br><code>make</code><br><code>make install</code><br>因为考虑到权限,我建议使用root管理员安装<br><br>当安装好之后,在命令框中输入python3<br>此时出现如下反馈<br><img src="/img/python/python03.png" alt="pythom3"><br><br>恭喜你,安装成功<br></center>

<hr>
<center><br>华丽的分割线<br><br>此时,我发现原来还有一种计算机语言可以简洁高效的令人发指<br>敲完第一个helloworld之后 我发现我已经爱上了这门语言<br><br>相比于系统庞大的java,<br>python显得小巧而强大<br><br>好了,废话就这么多.<br><br>以上<br><br></center>


]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[宇宙社会学]]></title>
      <url>http://weidablog.top/2016/12/21/threebody/</url>
      <content type="html"><![CDATA[<p>最近没有在偷懒,只是把所有的闲暇时间都拿来看小说了<a id="more"></a></p>
<center><br>博客没有什么更新,最主要的原因<br>是我最近在学习linux,<br>虽然这个操作系统传奇般的诞生经历以及世人的广大称赞,<br>可是我目前还没有感觉到<br>这个操作系统和其他操作系统所带来的不同的便利性<br>也许是因为我只是个初学者,<br>目前所接触到的仅仅是皮毛而已<br><br>也可能是因为我只是装了一个CtenOS的镜像虚拟机,<br>还没有在电脑上安装一个真正意义上的linux<br>目前只停留在一遍一遍在SecureCRT熟悉各种命令<br>我知道在linux上,我未来还有很长的路要走,<br>(当然,这些不是今天的重点)<br>今天顺手装了一下redis,熟悉了一下,感觉还不错.<br>于是,其余的闲暇时间,终于把我最近在看的黑暗森林看完了<br>(其实只是不想学东西,偷个懒而已…)<br><br>黑暗森林是刘慈欣地球往事三部曲的第二部<br>这本书还有一个响亮的名字<br>就是获得了第73届雨果奖也就是文学界的诺贝尔的三体<br><br>关于书的详细介绍网上有很多,<br>在这里我只谈下自己的感受<br><br>只是感受,谈不上看法,因为我已经被这部作品折服,<br><br></center>

<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a><center>首先</center></h2><center><br>首先我想说的是,真的很幸运,我看的第一部科幻作品是刘慈欣的三体<br><br>我之前对科幻题材不是很感冒<br>在中学时期喜欢武校小说<br>金梁古,几百本书也不知道看了多少遍<br><br>后来迷上了推理小说<br>江户川乱步,横沟正史等等<br>其中也一直很喜欢历史小说<br>总而言之.乱七八糟的书看过不少,网络小说也看了几本<br><br>但就是没有一部科幻.<br><br>我看完第二部黑暗森林之后我去豆瓣知乎找了一些书评来看<br>我原本以为这本书写的这么棒又拿了大奖,网上应该是好评如潮<br>但是事实我大失所望<br>网上有很多人说这本书除掉硬派科幻的外衣文笔一塌糊涂,人物描写苍白宇宙框架吹的很大但是内容空洞等等<br>我看了十分气愤<br>倒不是我个人喜欢这本书,爱屋及乌,连吐槽这本书的评论都看不下去.<br>只是因为网上的评论三言两语给作品下定论<br>所列举的毛病也十分笼统,甚至连一个能拿出具体例子的人都没有.<br>吐槽也是千篇一律,跟风嫌疑极大,更加可恶的,有一些看了一半没看的也好意思腆着个脸来评论.<br>对于这种人,<br>毛主席说过,没有调差就没有发言权,<br>想喷也麻烦先去看一遍好嘛.<br><br>我有个不怀好意的推测,我觉得也许这帮人是因为三体名气太大,如果自己也是跟随主流观点<br>岂不埋没了我的才华,索性就挑点毛病出来,但可惜这毛病挑的也是十分苍白空洞<br></center>

<h2 id="其次"><a href="#其次" class="headerlink" title="其次"></a><center>其次</center></h2><center><br>抛开作品本身,书中给我最大的影响也许是作者天马行空的想象力所塑造的宇宙哲学<br><br>黑暗森林法则,确实让我很感兴趣<br>人类像一个蹒跚学步的婴儿行走在宇宙中<br>不熟悉森林法则,于是在宇宙中大呼小叫,企图让大家注意到自己,一起建造一个和平的大同世界<br><br>这个只存在于幻想之中,生存是物种的第一要素<br>一旦陷入了作者所说的猜疑链中,宇宙中是没有安全可言的<br><br>但是如果真的如同作者所言,那么宇宙中是否最后只会有一个文明存活下来<br><br>我摘抄了几个我觉得比较好的观点,均来自知乎<br></center>


<blockquote>
<ol>
<li>宇宙资源有限；</li>
<li>文明发展对资源的消耗呈指数级增长；</li>
<li>（不同层级文明之间）战争的胜负只取决于技术能力；</li>
<li>生存是文明的第一需要；</li>
<li>存在技术爆炸的现象；</li>
<li>无差别打击比交流的成本低的多；<br>推理1. 几乎的文明都希望别的文明死，自己活（几乎所有的文明都是恶意的）。<br>推理2. 和灭掉别的文明相比，一个恶意文明更在乎自己是否能生存下去。<br>如果已知：宇宙中有一个低等文明，具体来说就是地球，被一万个高等文明发现，问地球的现状。<br>地球能否存活，要看其他高等文明的反应：<br>如果这个文明是冷静克制理性的，那么它会做如下思考：我自然希望地球文明灭亡，但出手的不应该是我。因为缺乏交流，我不知道我在宇宙中的科技地位（也许只比地球高那么一点点），我出手会增大我在别的神级文明的眼中被发现的概率，暴露显然比隐藏更危险。我不出手有可能会因为地球技术爆炸而被超过，但那时地球也会做如上思考，如果地球是冷静而克制的，它将不会出手，但如果他是暴躁而嗜杀的，我就面临被它击杀的危险，但是，宇宙中有很多文明，而我只是其中一个，不一定会被当作第一个攻击目标。（或者换个方向思考，我出手，将为全宇宙所有其他文明带来福利，自私的文明一定不会去这么做，除非有证据表明将有直接冲突。）如此以来，最明智的做法是发展隐藏自身的科技，而不是去攻击别的文明。<br>如果这个文明是暴力而嗜杀的，他将开枪将地球灭掉。但开枪会增大他被发现的概率（技术手段即会如此，没有完美的隐藏，也没有完美的谋杀）。如果他被发现，将有两种可能：一、只是单纯被发现（即原有的概率）。二、因攻击地球而被发现。如果是这种情况，发现者将会这样思考：已经证明此文明的暴力倾向概率较高。所以如果我们被它发现，将有很大概率被他攻击。如果发现者能力较低，将会保持不动。如果能力远高于暴力文明，将会考虑是否将其灭亡（考虑到技术爆炸的可能）。当然，他们会考虑来自更高文明的威胁，也可能选择不动。但总之，猎手文明被射杀的概率将较懦夫文明为高。<br>综上所述，猎手基因在文明中属于不利基因，将在所有的文明中保持一个较低水平。而懦夫基因（就是保持不动）将在文明中保持一个较高水平。那么这样的一个宇宙恰巧是现有宇宙的描述。可能有几百万个文明已经发现了地球文明，但是宇宙的战争历史告诫他们，不要动，否则，吃亏的可能是你自己。他们每个人都看不到对方（或者很难看到），但每个人都能看到地球文明这个二逼在快乐成长，但没有人动手。</li>
</ol>
<p>第一，不同宇宙文明，思维模式有本质的差异。<br>透明思维的文明，并不会妄想猜疑链问题。比如三体文明。无法确定宇宙文明中开放性思维文明的比例，无法事先认定猜疑链普遍存在于整个宇宙文明。</p>
<p>第二：猜疑链的链条两端是一种对等关系， 也就是说当两个文明相遇的时候， 双方的实力越接近，越可能产生猜疑链，当双方力量有质的差距的时候，猜疑链无法产生。–主不在乎。<br>文明进化的跨度贯穿整个时空轴，文明之间的技术/探知能力是严重不对等的，甚至差异超过你我的想象力。两个程度相近的文明相遇的可能性是非常苛刻的，在那之前他们会被更高等级的文明发现。</p>
<p>第三：对于高等文明来说，攻击的成本低于探测的成本.<br>这个姑且算是对的。<br>但是攻击带给自身的危险，必然会远远超过探测产生的危险。<br>黑暗森林中有个傻孩子坐在篝火边唱歌，无数双猎人的眼睛盯着他。<br>你会开枪吗？<br>篝火边的孩子，或许算是一个潜在的危险。<br>但是开枪射杀他的文明，在任何人眼中都是SSS级的危险。<br>其他高等文明有可能会主动搜寻这个袭击者的位置<br>关于是否暴露自己的位置，有种种辩解<br>但是—-弱小和无知不是生存的障碍，傲慢才是。<br>你无法理解，甚至无法想象的文明，对你来说就是高等文明<br>即使你用你最高的技术，最巧妙的掩饰。<br>在你所知的知识体系中，有种种理论支持。<br>在更高层次的文明眼中—你开枪的时候，也许和点起篝火的孩子没有两样。<br>生存如果是文明的第一要素。<br>那在黑暗森林中的文明， 不会假定，攻击的前后，自己是百分之百安全的。<br>它们要权衡的是，视野中可探测的弱小种子，与身后浩渺深邃的黑暗星空哪一个更可怕的问题。<br>有权衡，就不会是肆无忌惮的杀人狂。</p>
<p>第四：并不是别无选择。<br>书中其实已经给我们指出了第三条路。<br>三体利用技术手段，能够将人类世界的探知可逆和技术爆炸变成可控状态。<br>从实际情况看，探知可逆什么的完全是无谓的操心。<br>三体世界是有足够的能力，改造人类世界的。<br>它所缺少的只是时间而已。<br>因为时间紧迫，调控人类文明的过程过于简单粗暴，才引发了人类的危机感和后面的故事。<br>试想一下，如果比三体世界更为高等的文明，有着足够的时间。<br>它可以用更为巧妙的方式渗透到人类世界。<br>控制世界范围的社会形态，人类科技发展的方向和速度，甚至改变星球的气候，地质环境，运行轨道，土著生命的进化方向……<br>在黑暗森林中任何暴露都可能带来不必要的危险。<br>星际文明之间的最为合理的战争模式，就要尽可能的低调。<br>那么真正的星战或许会是—-文明渗透。<br>所谓技术爆炸也许只是文明渗透最后的结果。</p>
<p>第五：什么是技术爆炸？<br>逻辑推导中出现任何无逻辑的东西都是硬伤。<br>比如黑暗森林的技术爆炸。<br>作者未作解释，为什么文明会出现技术爆炸？<br>技术爆炸，科幻小说中这个名词不算新鲜了。<br>几乎都是一样的桥段，敌人很强大，但我们的文明技术发展速度是加速的，外星科技是匀速的，如此如此…..<br>每每读到这样的情节，身为人类的优越感油然而生。<br>作为YY小说可以理解，但如果暂时抛开人类可悲的自大感，来为技术爆炸思索一个合理的解释的话。<br>【一个问题】<br>如果三体世界的科技，通过降临派流传到人类世界，大幅改变地球文明形态……<br>以无知的人类视角来观察，这是地球文明的技术爆炸吗？<br>既然技术爆炸并不是基于逻辑的必然事件。我们仅仅可以确认的是，高等文明暗中介入低等文明的过程，会产生技术爆炸的效果。<br>那么我们如何确定，人类世界正在发生的技术爆炸是完全自发的？而不是某个高等文明的渗透进程……</p>
<p>三体的人类历史设定是照着现实世界来的，但最根本的区别是三体故事中确认了外星高等文明的存在，高等文明的渗透。<br>现实世界至今还没有有效的证据证明外星文明存在，如无必要，勿增实体，所以将技术爆炸归为自身，是唯一明智的理论了。（事实上，低等文明被渗透过程观察不到高等文明的存在才是常理）<br>而三体中已证实外星高等文明的存在，高等文明的渗透可能。技术爆炸为高等文明渗透，相比之下就逻辑上更简洁，因果更明确。<br>技术爆炸，到底是因？还是果？<br>把它作为推理的关键一环，那么这个推理有多大的说服力？<br>第六：就文中的设定。<br>存在多维度文明，高纬度碎片，在高纬度穿梭的经历，维度技术。<br>高维跳跃的技术是有十分的可能性的。<br>对于高等级文明来说距离并不是无解的。<br>现在的我们思维封闭，现在的我们无法解决猜疑链问题。现在的我们有技术爆炸，现在的我们科技里空间旅行会耗费大量的时间。<br>但是同时，现在的我们也没有能力进行实质的宇宙宇宙文明交流。</p>
<p>我们在宇宙中弱小，迷茫，无知，恐惧，所以会臆想出这样的问题。<br>但是宇宙文明的秩序，不是由我们这样的弱小文明决定的。<br>而等到我们的科技有能力跨越那一步的时候，文明会质变，视角也也会变了。<br>思维封闭，技术问题。<br>猜疑链，技术问题。<br>空间距离过远，技术问题。<br>探知可逆，技术问题。<br>技术爆炸……<br>当这些问题不是问题的时候，你会选择攻击吗？ </p>
</blockquote>
<p>以上</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><center>最后</center></h2><center><br>我想说的是目前为止,在整个三体作品中,我最喜欢的人物是章北海<br><br>这个人几乎是一个完美的化身<br>沉着冷静,目光独到,也不优柔寡断,善于学习,能隐忍.但是又具有一个标准军人的品质<br><br>不管是刺杀,还是带领自然选择号逃离,到最后打算诛杀其他船上的成员<br><br>章北海的思维犹如造物主一样,我觉得他是完美的,也许他最大的缺陷就是完美<br><br><br><br><br>好了,暂时说这么多,我继续把第三部看完<br><br><br></center>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XML的完全概要]]></title>
      <url>http://weidablog.top/2016/12/18/xml/</url>
      <content type="html"><![CDATA[<p>额,以下内容是我自己对自己学习xml的一个总结,方便回头抽空看两眼记忆的.<br>如果可以帮到你,也算是意外惊喜了<a id="more"></a></p>
<h1 id="XML的概要"><a href="#XML的概要" class="headerlink" title="XML的概要"></a><center>XML的概要</center></h1><hr>
<h2 id="xml和html"><a href="#xml和html" class="headerlink" title="xml和html"></a><center>xml和html</center></h2><center><br>XML可以用来描述数据，重点是‘数据是什么’。<br>HTML则是用来显示数据，重点是‘如何显示数据’。<br><br>XML是用来存放数据的<br>XML不是HTML的替代品，XML和HTML是两种不同用途的语言。<br>XML是被设计用来描述数据的，重点是：什么是数据，如何存放数据。<br>HTML是被设计用来显示数据的，重点是：显示数据以及如何显示数据更好上面。<br>HTML是与显示信息相关的, XML则是与描述信息相关的<br></center>

<h2 id="XML-什么也不做"><a href="#XML-什么也不做" class="headerlink" title="XML 什么也不做"></a><center>XML 什么也不做</center></h2><center><br>XML 被设计成什么都不做的。<br>也许看起来很难理解，但事实上XML确实什么都不做。XML只是用来组织、存储和发送信息的。<br>下面的例子是Ordm给Lin的便条，使用的是XML格式：<br><br>XML标记并不是预先规定好的，你必须创造你自己的标记。<br><br>XML并不是HTML的替代品。<br>XML并不是HTML的替代品，理解这一点非常重要。<br>在将来的网页开发中，XML将被用来描述、存储数据，<br>而HTML则是用来格式化和显示数据的。<br><br>对于XML最好的形容可能是:<br>XML是一种跨平台的，与软、硬件无关的，处理信息的工具。<br><br>通过XML,你可以在HTML文件之外存储数据。<br>在不使用XML时，HTML用于显示数据，<br>数据必须存储在HTML文件之内；<br>使用了XML，数据就可以存放在分离的XML文档中。<br>这种方法可以让你集中精力去到使用HTML做好数据的显示和布局上，<br>并确保数据改动时不会导致HTML文件也需要改动。<br>这样可以方便维护页面。<br><br><b><br>通过XML,我们可以在不兼容的系统之间交换数据。<br>在XML文档中, 忽略结束标记是不符合规定的。<br>这与HTML不一样, XML标记是大小写敏感的。<br></b><br></center>

<h2 id="所有的XML文档必须有一个根元素"><a href="#所有的XML文档必须有一个根元素" class="headerlink" title="所有的XML文档必须有一个根元素"></a><center>所有的XML文档必须有一个根元素</center></h2><center><br>XML文档中的第一个元素就是根元素。<br>xml中的空白会被解析保留<br>XML确实没有什么特别的地方。<br>他只是一些用尖括号扩在一起的普通的纯文本。<br>编辑普通文本的软件也可以编辑XML文档。<br>然而在一个支持XML的应用程序中，<br>XML标记往往对应着特殊的操作，<br>有些标记可能是可见的，<br>而有些标记则可能不会显示出来，<br>而不会有什么特殊的操作。<br><br>在HTML中 (在XML中也一样)元素的属性提供了元素的额外信息<br><br>在xml的使用中,我们应该做到尽量的避免使用属性<br>在这里列举一些属性包含的问题<br>1.属性不能包含多个值（子元素可以）。<br>2.属性不容易扩展。<br>3.属性不能够描述结构（子元素可以）。<br>4.属性很难被程序代码处理。<br>5.属性值很难通过DTD进行测试。<br>如果使用属性来存储数据，<br>那么所编写的XML文档一定很难阅读和操作。<br>尽量使用元素来描述数据，<br>仅使用属性来描述那些与数据关系不大的额外信息。<br><br>‘当然,凡事都应该有例外<br>有些时候应该为一个元素设计一个ID引用，<br>通过这个ID可以引用存取特定的XML元素，就象HTML中的name和id属性一样<br>符合语法的XML文档称为结构良好的XML文档。<br>通过DTD验证的XML文档称为有效的XML文档。<br><br>在xml技术中，我们可以编写一个文档来约束一个xml文件的书写的内容规范，<br>这个就称之为xml约束。<br><br>简单说，约束就规定了xml文件中可以写什么，不可以写什么。<br></center>


<h2 id="what-is-DTD"><a href="#what-is-DTD" class="headerlink" title="what is DTD?"></a><center>what is DTD?</center></h2><center><br><a href="http://www.runoob.com/dtd/dtd-tutorial.html" target="_blank" rel="external">DTD</a><br>DTD元素<br><br>       格式1&lt;!ELEMENT 元素名称 类别&gt;<br>       格式2 &lt;!ELEMENT 元素名称 (元素内容)&gt;<br>       在dtd中特殊符号:<br>              ?  表示对象可以出现，但是只能出现一次。<br>              *表示对象可以出现0次或多次<br>              +表示对象可以出现1次或多次。<br>              ()用于元素分组<br>              ｜表示在列出的对象中选择一个<br>              ,（逗号）表示该对象必须按照指定的顺序出现。<br>       元素类别<br>       #PCDATA<br>              表示元素可以包含任意字符，但是不能是子元素。<br>       ANY<br>              表示可以是任意的内容<br>       EMPTY<br>              表示元素不可以包含任何内容，只能使用属性。<br></center>

<h2 id="SCHEMA约束"><a href="#SCHEMA约束" class="headerlink" title="SCHEMA约束"></a><center>SCHEMA约束</center></h2><center><br>       Schema约束它是dtd替代者。Schema约束文件的后缀名是xsd<br>       Dtd与schema区别<br>1.dtd不遵守xml语法，而schema它遵守xml语法，它本质上就是一个xml<br>2.dtd数据类型不完善，而schema它有丰富数据类型<br>3.dtd只能有一个应用于xml文件，使用schema可以多个schema约束xml文件。<br></center>


<h2 id="CDATA区域"><a href="#CDATA区域" class="headerlink" title="CDATA区域"></a><center>CDATA区域</center></h2><center><br>xml通常情况下会处理xml内的所有文本<br>CDATA区域中的内容不会被解析，而是原样展示。<br>例如<code>&lt;![CDATA[&quot; 标记开始，以&quot;]]&gt;&quot;</code><br><br>CDATA部件之间不能再包含CDATA部件（不能嵌套）。<br>如果CDATA部件包含了字符”]]&gt;” 或者”&lt;![CDATA[“ ，将很有可能出错哦。<br></center>

<h2 id="使用XSL来显示XML文档"><a href="#使用XSL来显示XML文档" class="headerlink" title="使用XSL来显示XML文档"></a><center>使用XSL来显示XML文档</center></h2><center><br>XSL是XML的可扩展样式单语言。<br>XSL (全称是：可扩展的样式单语言，<br>the eXtensible Stylesheet Language)比CSS样式单功能要强大的多。<br>XSL的一个主要的用途就是将XML文档转换成HTML格式的文件，<br>然后再交付给浏览器，由浏览器显示转换的结果:<br></center>

<h2 id="名称空间-命名空间"><a href="#名称空间-命名空间" class="headerlink" title="名称空间(命名空间)"></a><center>名称空间(命名空间)</center></h2><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a><center>命名冲突</center></h3><center><br>因为XML文档中使用的元素不是固定的，<br>那么两个不同的XML文档<br>使用同一个名字来描述不同类型的元素的情况就可能发生。<br>而这种情况又往往会导致命名冲突<br></center>

<h3 id="使用前缀解决命名冲突问题"><a href="#使用前缀解决命名冲突问题" class="headerlink" title="使用前缀解决命名冲突问题"></a><center>使用前缀解决命名冲突问题</center></h3><center><br>不同属性的同名标签加上前缀<br><code>&lt;h:table&gt;</code><br></center>

<h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a><center>使用命名空间</center></h3><center><br>例如在重名标签下<br><code>&lt;f:table xmlns:f=&quot;http://www.w3schools.com/furniture&quot;&gt;</code><br>我们管xsd文件叫做模式文档(约束文档),管xml文件，实例文档。<br>编写一个xml shcema约束文档后，<br>通常需要将这个文件中声明的元素绑定到一个URI地址上，<br>在xml schema技术中我们管这个过程叫做将声明的元素绑定到名称空间。<br>以后，我们的xml文件被解析引擎解析时，<br>可以知道我们这些xml文件中的元素来自哪里，<br>被谁约束。<br></center>

<h2 id="关于schema中属性"><a href="#关于schema中属性" class="headerlink" title="关于schema中属性"></a><center>关于schema中属性</center></h2><center><br><code>&lt;attruibute name=””  type=”” use=””&gt;</code><br>Name属性名称<br>Type 属性类型<br>Use 可取值有三个<br>       Required 必须<br>       Optional 是可选值<br>       Prohibited 无属性值<br><code>&lt;attribute name=&quot;category&quot; type=&quot;string&quot; use=&quot;required&quot;/&gt;</code><br></center>

<h2 id="XML编码"><a href="#XML编码" class="headerlink" title="XML编码"></a><center>XML编码</center></h2><center><br>XML文档可以包含外文字符比如挪威语或者法语<br>中文当然也可以！<br>使用一种支持Unicode编码格式的编辑器。<br>确信你知道自己正在使用那种编码格式。<br>在XML文档中使用属性声明设置编码格式。<br>对于中文,我们的建议当然是utf-8<br></center>

<h2 id="将XML文档载入数据岛"><a href="#将XML文档载入数据岛" class="headerlink" title="将XML文档载入数据岛"></a><center>将XML文档载入数据岛</center></h2><center><br>数据岛可以访问XML文件。<br>通过数据岛，可以把XML文档引入到HTML页面中。<br><code>&lt;xml src=&quot;cd_catalog.xml&quot; id=&quot;xmldso&quot; async=&quot;false&quot;&gt;</code><br><br>使用上面示例代码，<br>可以把cd_catalog.xml文件载入一个叫”xmldso”的数据岛中。<br>属性async=”false”的作用是在HTML处理器开始处理XML数据以前，<br>必须确保XML文档中的所有数据都被载入到内存中。<br><br>把数据岛绑定到<code>&lt;span&gt;</code> 或者<code>&lt;div&gt;</code> 元素上<br><br><code>&lt;span&gt;</code>或<code>&lt;div&gt;</code>元素都可以用来显示XML数据。<br>没有必要使用table元素来显示XML数据，<br>数据可以通过数据岛绑定到任何一个HTML元素上。<br>所要做的就是在你得页面中添加一些<span> 或者<div>元素，<br>使用数据资源属性把每一个元素和XML文档元素绑定起来，<br>就象下面这样:<br>    <code>&lt;br /&gt;Title:</code><br>    <code>&lt;span datasrc=&quot;#xmldso&quot; datafld=&quot;TITLE&quot;&gt;&lt;/span&gt;</code><br>    <code>&lt;br /&gt;Artist:</code><br>    <code>&lt;span datasrc=&quot;#xmldso&quot; datafld=&quot;ARTIST&quot;&gt;&lt;/span&gt;</code><br>    <code>&lt;br /&gt;Year:</code><br>    <code>&lt;span datasrc=&quot;#xmldso&quot; datafld=&quot;YEAR&quot;&gt;&lt;/span&gt;</code><br></div></span></center>

<h2 id="行为——什么是行为？"><a href="#行为——什么是行为？" class="headerlink" title="行为——什么是行为？"></a><center>行为——什么是行为？</center></h2><center><br>行为是一个新的CSS属性<br>行为属性可以指向一个分离的XML文件，这个XML文件包含了能够改变XML或者HTML页面的元素或显示样式的脚本代码。<br></center>

<h2 id="以上-其他的-以后想起来再补充"><a href="#以上-其他的-以后想起来再补充" class="headerlink" title="以上,其他的,以后想起来再补充"></a><center>以上,其他的,以后想起来再补充</center></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[当我敲代码的时候,我在听些什么?(二)]]></title>
      <url>http://weidablog.top/2016/12/17/essay02/</url>
      <content type="html"><![CDATA[<p>Misty(Tsuyoshi Yamamoto)<a id="more"></a></p>
<h2 id="Misty"><a href="#Misty" class="headerlink" title="Misty"></a><center>Misty</center></h2><center><br>这首曲子仿佛和名字一样,<br>与生俱来拥有一种魔力<br>我暂且称之为如同迷雾一样<br><br>听过若干版本的misty,<br>包括不同乐器演绎的<br>唯独这个三重奏最得我深爱<br><br><img src="/img/guitar/jazz/a.png" alt="a"><br><br><br>著名爵士钢琴演奏家森木崎先生领衔的爵士三重奏组<br>在当代国际乐坛享有盛誉，<br>他们的演奏热情、细腻、刚健而奔放，<br>具有无限的音乐张力，<br>而且在即兴演奏上独具风格和创意。<br>爵士音乐在当代 100多年的发展历程里，<br>无论是曲式、形式、节奏、和声都非常的成熟，<br>走向完美。<br>注重情调、音乐格调、音乐气度、音色在音乐氛围的塑造等因素，<br>在当代已经成为主要的共识和潮流，<br>不同年代都有出现过有代表性的演奏家和乐队组合，<br>他们在多年的磨练融合里形成引领音乐潮流的方向，<br>而森木崎爵士三重奏乐组无疑是他们其中杰出的一员。<br></center>

<center><br><img src="/img/guitar/jazz/b.png" alt="b"><br><img src="/img/guitar/jazz/d.png" alt="d"><br><br>我觉得这首曲子还是不适合敲代码的过程中听,<br>代码敲累了,来一首<br>醒脑提神<br><br><a href="http://music.163.com/#/m/song?id=545882&amp;userid=89647372" target="_blank" rel="external">Misty</a><br><br></center>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于CPU占用率的问题]]></title>
      <url>http://weidablog.top/2016/12/15/artofcode/</url>
      <content type="html"><![CDATA[<p>前阵子在一片忘记了名字的文章中发现了一道很有意思的题目,特意在网上把这本书也找了出来,终于耽搁到昨日才有时间拿出来看一看,书的名字稍后再说,<br><a id="more"></a></p>
<h2 id="一-提出问题"><a href="#一-提出问题" class="headerlink" title="一.提出问题"></a><center>一.提出问题</center></h2><center><br>题目是这样的<br><br>我们都知道如何调用windows操作系统中的任务管理器,<br>在任务管理器中,我们可以一目了然的看到cup的使用率<br>其中包括内存进程等等(以win7操作系统为例),当然这些不是我们需要去分析的<br><br>那有没有这样一种可能<br>可以通过编写一个程序,让我们的cpu稳定在百分之五十呈一条直线?<br>(在这里可以暂停一下,大家可以思考自己的想法)<br><br><br><br><br><br>如果听到这样的题目,大多数人会感到意外<br>如果是在考试中或者面试中遇到,很可能会让你手忙脚乱<br><br>这题看上去很复杂,因为我们不知道影响cpu使用率到底都有哪些因素<br>我们可以通过任务管理器的进程看到哪些程序在使用cpu,但是这样你会发现有很多前台后台,系统程序等等<br>总而言之,这会让这道题目看起来很复杂<br>因为甚至一次屏幕的闪烁,一次鼠标的点击都会影响到所谓的使用率<br>那我们该如何控制好这些进程,然后cpu固定在百分之五十<br><br></center>

<h2 id="二-分析"><a href="#二-分析" class="headerlink" title="二.分析"></a><center>二.分析</center></h2><center><br>我们可以写一个死循环,让程序一直保持无休止的运行<br>这样cpu使用率或许可以保持一条直线,只是可惜不是在中间的位置<br><br>但是,如果在持续的运转中,我们利用sleep()函数让程序休息一下<br>只要时间规划好,我们可以让程序在持续的变动中维持下来<br><br>学过微积分的朋友都知道,所谓的曲线,也是由无数条直线组成的,所以<br>我们也可以通过无数微小的变动得出的曲线,组成一条宏观上的直线<br><br>我们只要在任务管理器刷新的一个周内,cpu忙的时间和刷新周期的比率,(这就是占用率)<br>统计的平均值,保持在百分之五十,这样,一条看起来像是直线的曲线,就完成了<br><br></center>

<h2 id="三-解答"><a href="#三-解答" class="headerlink" title="三.解答"></a><center>三.解答</center></h2><center><br>首先什么是CPU占用率？<br>在任务管理器的一个刷新周期内，CPU忙（执行应用程序）的时间<br>和刷新周期总时间的比率，就是CPU的占用率，<br>也就是说，任务管理器中显示的是每个刷新周期内CPU占用率的统计平均值。<br>例如我的cpu是2.4Ghz,(2.4<em>10^9</em>2)/5=9.6*10^8(循环/秒)<br>这是cpu一秒钟可以执行空循环的次数<br>我们以10毫秒为单位,降低两个数量级,让cpu在工作和休息中来回切换<br>最后,可以得到如下代码<br></center>


<pre><code>public class CPUTest 
{ 
    public static void main(String[] args) 
    { 
        long startTime = 0; 
        int busyTime = 10; 
        int idleTime = 10;
        while (true) 
        { 
            startTime = System.currentTimeMillis(); 
            while (System.currentTimeMillis() - startTime &lt;= busyTime) 
                try 
            { 
                Thread.sleep(idleTime); 
            } 
            catch (InterruptedException e) 
            { 
                e.printStackTrace(); 
            }
        } 
    }
}
</code></pre><h2 id="四-延伸"><a href="#四-延伸" class="headerlink" title="四.延伸"></a><center>四.延伸</center></h2><center><br>当然,我们可以将问题延伸一下<br><br>使cpu占用率成为一条直线,具体的占用率大小由参数决定(参数范围1~100)<br><br>使cpu的占用率成为一条正弦曲线<br><br><br>以上<br></center>


<h2 id="哦-对了"><a href="#哦-对了" class="headerlink" title="哦,对了"></a><center>哦,对了</center></h2><p><center>这本书叫做”编程之美”</center></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mybatis中关于ResultType和ResultMap的区别详解]]></title>
      <url>http://weidablog.top/2016/12/12/mybatis01/</url>
      <content type="html"><![CDATA[<h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a><center>如题<a id="more"></a></center></h2><center><br>最近在学习mybatis.这是一种和habernate类似的持久层框架<br>不同的是mybatis需要自己手写sql语句<br>当然,这两者的区别也不完全只有这一点<br>今天的重点不是这个,而是我在学习到关联查询的地方时<br>有一个细节让我纠结了很久<br>在这里我简单总结一下<br><br>个人总结,仅供参考,具体正确与否还需读者自行判断<br></center>

<h2 id="ResultType"><a href="#ResultType" class="headerlink" title="ResultType"></a><center>ResultType</center></h2><hr>
<center><br>当提供的返回类型属性是resultType时，<br>MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性。<br>所以其实MyBatis的每一个查询映射的返回类型都是ResultMap，<br>只是当提供的返回类型属性是resultType的时候，<br>MyBatis对自动的给把对应的值赋给resultType所指定对象的属性。<br></center>

<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a><center>ResultMap</center></h2><hr>
<center><br>当提供的返回类型是resultMap时，<br>因为Map不能很好表示领域模型，<br>就需要自己再进一步的把它转化为对应的对象，<br>这常常在复杂查询中很有作用。<br></center>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a><center>区别</center></h2><hr>
<center><br>首先,这两者不可以同时使用<br>其次从字面上理解<br>resultType 就是返回的类型<br>resultMap 返回的是一个结果集，<br>这个结果集一般是用过resultMap节点来配置的，<br>相应的type一般是一个pojo。<br><br>而resultType则就是类型，<br>包括了，int,sring,以及类似model这样的Object类型。<br><br><br>如果没有特殊的要求，使用resultType是比较方便，<br>只要能够保证sql查询的列和pojo属性名一致可以映射成功，<br>如果pojo中属性少了，添加属性即可。<br><br>特殊的要求：<br>如果需要将关联查询的信息映射到pojo的pojo属性中，<br>为了获取数据方便，可以使用resultMap。<br>如果使用延迟加载，只能使用resultMap。<br><br>所以,当你的对象中包含另外一个对象的话<br>resultMap是一个不错的选择<br>例如:<br><img src="/img/mybatis/mybatis02.png" alt="mybatis02"><br><br>以上<br></center>

]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[当我敲代码的时候,我在听些什么?(一)]]></title>
      <url>http://weidablog.top/2016/12/11/essay01/</url>
      <content type="html"><![CDATA[<p>falling to the sky(向天空坠落)<a id="more"></a></p>
<h2 id="falling-to-the-sky"><a href="#falling-to-the-sky" class="headerlink" title=" falling to the sky"></a><center> falling to the sky</center></h2><center><br>这是首歌来自日本的一个乐队archaique Smile<br><br>他们的处女作非常惊艳<br>“On The Eternal Boundary”<br>是我最喜欢的专辑之一<br><br>然而,我每次在编程或者看书的时候,<br>我喜欢打开MP3开始播放这首曲子<br><br>我不会为这首歌有一点点的分心,我也不会因为某些事情而出神<br>事实上当我听他的时候<br>我认为<br>他早已和环境融为一体<br><br><img src="/img/guitar/postrock/On The Eternal Boundary.png" alt="On The Eternal Boundary"><br><br>现在,我希望你可以找一个隔音效果好的耳机<br>如果有组合音响就更好了<br>最好关掉手机,排除一切外界干扰<br>点开链接之后<br>把音量调到最大…<br><br><a href="http://www.bilibili.com/video/av5592002/" target="_blank" rel="external">falling to the sky</a><br><br></center>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[当我敲代码的时候,我在听些什么(序)]]></title>
      <url>http://weidablog.top/2016/12/10/essay/</url>
      <content type="html"><![CDATA[<p>#半夜无眠,闲扯两句<a id="more"></a></p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言:"></a><center>序言:</center></h2><hr>
<center><br>嗯<br>在我成为一个程序员之前<br>我的梦想很简单,就是成为一个流浪歌手<br><br>重点是歌手,其次是流浪,或者当一个音乐制作人<br><br>总之,我的青春和每一个摇滚少年一样<br>我怀揣了一个自己的音乐梦<br><br>因为家庭的原因,我没有很好的条件从小开始接触这门艺术,<br>我在高中的时候第一次接触吉他,<br>而到了大学<br>我二十岁的时候,我才第一次摸到钢琴<br>第一次知道钢琴的十二个音<br>第一次知道大小三和弦,转换和弦,宫商角徵羽等等<br><br>我很感谢当时为我无私提供帮助的很多人<br>那个时候<br>我觉得我就是在完成我的梦想<br>我那一年疯狂的逃课,在外面找培训班学习乐器<br>在琴房学习钢琴,在网上学习cubase编曲…<br><br>但是最后我失败了<br>我觉得原因在于我<br>在生活面前,我选择了妥协<br>我的想法突然开始发生转变,我认为我<br>应该做一些和普通人一样的事情<br><br>我没有我所认为的天赋禀异,所以,在一条前途生死未仆的路上<br>我最终自己选择了放弃<br>走了一条大部分人认为<br>相对安全的道路<br><br>我知道从那一刻开始,我的生活少了很多故事<br><br>&gt;“是谁来自山川湖海 , 却囿于昼夜、厨房与爱”<br></center>

<h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a><center>正题</center></h2><hr>
<center><br>编程是一件很哲学的事情<br><br>至少我是这样认为<br><br>音乐我觉得是代码的催化剂,即使敲不出什么惊天动地的代码<br>但是,我认为,这应该是每个程序员不可或缺的东西<br><br>我在这里专门开了一个板块<br><br>我会不定期的推荐一首,我最近,或者是以前,敲代码经常听的一首歌<br><br>不定期更新,每次只有一首<br></center>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git的快速入门(2)]]></title>
      <url>http://weidablog.top/2016/12/10/git02/</url>
      <content type="html"><![CDATA[<center><br>在这里我将会引入git版本仓库的概念,<br>并且,如果你是个新手,<br>我将会隆重想你介绍程序员的facebook–github代码托管仓库<br><a id="more"></a><br></center>

<h2 id="三-仓库"><a href="#三-仓库" class="headerlink" title="三.仓库"></a><center>三.仓库</center></h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a><center>1.创建</center></h3><center><br>Git做为一个资源管理和跟踪系统，<br>如果想让git托管你的文件<br>那么首先你得让Git知道你需要管理的文件在哪。<br>巧妇难为无米之炊,git功能再强大,你如果什么都不交代<br>他也是力不从心的<br><br>那如何让git托管我们的文件呢?<br><br>其实很简单,在你需要管理的项目的文件夹下<br>右键选择git bash<br>然后运行”git init”命令。<br><strong><em><br><img src="/img/git/git05.png" alt="git05"><br><br>这个时候Git就会在该目录下生成一个.git的隐藏目录，<br>这样git进行版本控制和内容跟踪的所有文件都在该文件夹下。<br><br>如果想查看隐藏目录的内容,可以在命令行输入”ls -ah”
</em></strong><br><img src="/img/git/git06.png" alt="git06"><br><br>但是我建议不要修改.git文件夹下的任何文件<br><em>*</em><br></center>

<h3 id="2-添加"><a href="#2-添加" class="headerlink" title="2.添加"></a><center>2.添加</center></h3><center><br>将你需要托管的代码放在上一步部署的根文件夹下面<br>假设你在demo文件夹下运行了”git init”指令<br><br>此时你又在demo文件夹下创建了test.txt.<br>那么,执行下面两步,可以完成<br><br>文件路径根据自己实际情况而定<br><br>用”git add 文件名.后缀”告诉git,将文件添加到仓库<br><strong><em><br><img src="/img/git/git07.png" alt="git07"><br><br>用”git commit”将文件提交到git仓库
</em></strong><br><img src="/img/git/git08.png" alt="git08"><br><br>“简单解释一下git commit命令，<br>-m后面输入的是本次提交的说明，可以输入任意内容<br>当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，<br>但是强烈不建议这么干，<br>因为代码的可读性对自己对别人都很重要。”<br><br><em>*</em><br>commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br>‘<br>$ git add file1.txt<br>$ git add file2.txt file3.txt<br>$ git commit -m “add 3 files.”<br>‘<br></center>

<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a><center>未完待续</center></h3><hr>
<h2 id="四-github远程仓库"><a href="#四-github远程仓库" class="headerlink" title="四.github远程仓库"></a><center>四.github远程仓库</center></h2><center><br>一台电脑上也是可以克隆多个版本库的，<br>只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，<br>因为一台电脑上搞几个远程库完全没有意义，<br>而且硬盘挂了会导致所有库都挂掉<br><br>实际情况往往是这样，<br>找一台电脑充当服务器的角色，每天24小时开机，<br>其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，<br>并且各自把各自的提交推送到服务器仓库里，<br>也从服务器仓库中拉取别人的提交。<br><br>这个世界上有个叫GitHub的神奇的网站，<br>从名字就可以看出，这个网站就是提供Git仓库托管服务的，<br>所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。<br><br>看到这里,你需要做的是请自行注册GitHub账号。<br><br><a href="https://www.zhihu.com/question/20070065#answer-27250329" target="_blank" rel="external">如何熟悉github?</a><br><br>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，<br>所以，<br>需要一点设置：<br><br><a href="http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="external">配置SSH-KEY</a><br><br>为什么GitHub需要SSH Key呢？<br>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，<br>而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。<br><br>当然，GitHub允许你添加多个Key。<br>假定你有若干电脑，<br>你一会儿在公司提交，<br>一会儿在家里提交，<br>只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。<br><br><em>*</em><br></center>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git的快速入门(1)]]></title>
      <url>http://weidablog.top/2016/12/10/git01/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）<br>                   —廖雪峰<br><a id="more"></a></p>
</blockquote>
<center><br>这篇博客的搭建用了hexo+github psges,花了三天时间,走了不少弯路<br>好在最后终于成功<br>至于怎么搭建的博客,在这里就不赘述了<br>百度一下,答案有很多,<br>而且,<br>我相信,肯定写的都比我写的好<br><br>但是在搭建完成之后,我对git却产生了很大的兴趣,于是找了一些资料来学习一下<br>当然,这篇文章只是在对我自己学习git的过程中<br>一些知识理解和感悟的总结<br>我也是初学者,总结这东西,必定会有不少纰漏<br>但是我会一直更新这篇文章的进度<br>尽最大努力,让他看起来<br>更加的,完整<br><em>*</em><br><img src="/img/git/git04.png" alt="git04"><br></center>

<h2 id="一-git是什么"><a href="#一-git是什么" class="headerlink" title="一.git是什么"></a><center>一.git是什么</center></h2><center><br>如果有过web开发经验的话<br>必定会接触到一个叫做版本控制系统的东西,<br>什么是版本控制系统<br>因为大部分项目都不可能是由一个人从头到尾开发完成,一旦有了分工合作,那么,我们就要解决一个在分工合作中<br>出现的一个各个版本不同的问题<br>我之前在学习spring的时候接触了一个叫做svn的版本控制系统<br>这是一个集中式的分布管理系统,<br>什么是集中式版本管理系统?<br><br>&gt;集中式版本控制系统，版本库是集中存放在中央服务器的，<br>&gt;而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，<br>&gt;然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，<br>&gt;你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。<br><br><img src="/img/git/git02.png" alt="git02"><br><br>集中式版本控制系统最大的毛病就是必须联网才能工作<br>不过在当时,我用的是局域网,所以也没有太大的感觉,<br>而git恰恰相反,这是一种分布式的版本管理系统<br><br>首先，分布式版本控制系统根本没有所谓的“中央服务器”，<br>每个人的电脑上都是一个完整的版本库，<br>当你工作的时候，就可以不需要联网<br>因为版本库就在你自己的电脑上。<br><br><img src="/img/git/git03.png" alt="git03"><br><br>当需要你们整合文件的时候<br>比方说两个人都对某个文件做出了修改<br>那么两个人之间只需把各自的修改推送给对方，<br>就可以互相看到对方的修改了。<br><br>和集中式版本控制系统相比，<br>分布式版本控制系统的安全性要高很多，<br>Git中每个克隆(clone)的版本库都是平等的。<br>你可以从任何一个版本库的克隆来创建属于你自己的版本库，<br>同时你的版本库也可以作为源提供给他人<br>而集中式版本控制系统的中央服务器要是出了问题，<br>会导致所有人都没法干活了。<br><br>而svn有个让我很费解的地方在于<br>svn解决冲突是拼手速,如果你可以早提交,则万事大吉,平安无事<br>如果晚提交,哪怕代码性能非常好,也会有相当麻烦的冲突解决<br></center>

<hr>
<h2 id="二-git的安装"><a href="#二-git的安装" class="headerlink" title="二.git的安装"></a><center>二.git的安装</center></h2><center><br>百度遍地的教程,我用的是windows系统,当你可以在菜单看到git-bush的图标<br>点开可以看到一个类似dos命令窗口的东西,那么说明你安装成功<br><img src="/img/git/git01.png" alt="git01"><br>设置好账号密码之后,就可以使用git了<br><em>*</em><br></center>

<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a><center>未完待续</center></h2><p>参考:<br>   <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方主页</a><br>   <a href="http://www.nowamagic.net/academy/detail/48160205" target="_blank" rel="external">git背后的故事</a><br>   <a href="https://git-scm.com/docs/gittutorial" target="_blank" rel="external">git官方教程</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Welcome]]></title>
      <url>http://weidablog.top/2016/12/07/again/</url>
      <content type="html"><![CDATA[<h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a><center>Welcome</center></h2><hr>
<h2 id="嗯"><a href="#嗯" class="headerlink" title="嗯,"></a><center>嗯,</center></h2><center>终于可以说点什么了<a id="more"></a><br>其实这个网站内容的话我会慢慢补充<br>我想,以后大多会更新一些技术方面的文章,<br>关于java js git 前端后台以及我感兴趣的领域<br>当然<br>偶尔我会写一些兴趣爱好相关的<br>若干链接都没有弄好,<br>不过你们也可以尝试着四处点点<br>可惜,他不会给你反馈<br><br>你们可以通过微信联系到我<br>Wechat:xiongweida002<br>或者,email<br>值得高兴的是,邮件的按钮是有用的,<br>你们可以通过旁边的菜单找到他<br><br>今天是这个网站的生日<br><br>所以,HappyBirthday<br>以及所有今天过生日的人<br>就这样<br></center>]]></content>
    </entry>
    
  
  
</search>
